package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"time"
)

type AutoGenerated struct {
	Status struct{} `json:"status"`
	Data   []struct {
		ID                  int         `json:"id"`
		Rank                int         `json:"rank"`
		Name                string      `json:"name"`
		Symbol              string      `json:"symbol"`
		Slug                string      `json:"slug"`
		IsActive            int         `json:"is_active"`
		Status              int         `json:"status"`
		FirstHistoricalData time.Time   `json:"first_historical_data"`
		LastHistoricalData  time.Time   `json:"last_historical_data"`
		Platform            interface{} `json:"platform"`
	} `json:"data"`
}

type AutoGenerated2 struct {
	Status interface{}     `json:"status"`
	Data   map[string]Data `json:"data"`
}

type Data struct {
	ID              int         `json:"id"`
	Name            string      `json:"name"`
	Symbol          string      `json:"symbol"`
	Category        string      `json:"category"`
	Description     string      `json:"description"`
	Slug            string      `json:"slug"`
	Logo            string      `json:"logo"`
	Subreddit       string      `json:"subreddit"`
	Notice          string      `json:"notice"`
	Tags            []string    `json:"tags"`
	TagNames        []string    `json:"tag-names"`
	TagGroups       []string    `json:"tag-groups"`
	Urls            interface{} `json:"urls"`
	Platform        interface{} `json:"platform"`
	DateAdded       time.Time   `json:"date_added"`
	TwitterUsername string      `json:"twitter_username"`
	IsHidden        int         `json:"is_hidden"`
	DateLaunched    time.Time   `json:"date_launched"`
	ContractAddress []struct {
		ContractAddress string `json:"contract_address"`
		Platform        struct {
			Name string `json:"name"`
			Coin struct {
				ID     int    `json:"id,string"`
				Name   string `json:"name"`
				Symbol string `json:"symbol"`
				Slug   string `json:"slug"`
			} `json:"coin"`
		} `json:"platform"`
	} `json:"contract_address"`
	SelfReportedCirculatingSupply interface{} `json:"self_reported_circulating_supply"`
	SelfReportedTags              interface{} `json:"self_reported_tags"`
	SelfReportedMarketCap         interface{} `json:"self_reported_market_cap"`
	InfiniteSupply                bool        `json:"infinite_supply"`
}

type Data2 struct {
	ID              int               `json:"id"`
	Name            string            `json:"name"`
	Symbol          string            `json:"symbol"`
	Slug            string            `json:"slug"`
	ContractAddress map[string]string `json:"contractAddress"`
}

func GetApi[T any](tokenData T, url string) (T, error) {
	resp, err := http.Get(url)
	if err != nil {
		return tokenData, err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return tokenData, err
	}

	if err := json.Unmarshal(body, &tokenData); err != nil {
		log.Print(body)
		return tokenData, err
	}
	return tokenData, nil
}

func WriteFile[T any](file *os.File, tokenData T) error {
	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	if err := encoder.Encode(tokenData); err != nil {
		return fmt.Errorf("Error encoding data:", err)
	}
	return nil
}

func ReadFile(file *os.File, tokenData *AutoGenerated) {
	decoder := json.NewDecoder(file)
	if err := decoder.Decode(&tokenData.Data); err != nil {
		fmt.Println(err)
	}
}

func main() {
	var ApiOne AutoGenerated
	var err error
	var url string

	file, err := os.OpenFile("ID-Slug.json", os.O_APPEND|os.O_CREATE|os.O_RDWR, 0644)
	if err != nil {
		fmt.Println("Error opening/creating file:", err)
		return
	}
	defer file.Close()
	file2, err := os.OpenFile("Result.json", os.O_APPEND|os.O_CREATE|os.O_RDWR, 0644)
	if err != nil {
		fmt.Println("Error opening/creating file:", err)
		return
	}
	defer file.Close()

	ReadFile(file, &ApiOne)

	var count int
	url = "https://api.vultisig.com/cmc/v1/cryptocurrency/info?id="
	ids := make([]string, 0)
	var helo []Data2

	for _, m := range ApiOne.Data {

		ids = append(ids, fmt.Sprintf("%d", m.ID))
		count++
		if count == 1000 {
			var ApiTwo AutoGenerated2

			count = 0

			url = url + strings.Join(ids, ",")

			ApiTwo, err = GetApi(ApiTwo, url)
			if err != nil {
				panic("error for api one")
			}
			url = "https://api.vultisig.com/cmc/v1/cryptocurrency/info?id="
			ids = nil
			for _, two := range ApiTwo.Data {

				test := make(map[string]string)

				for _, tc := range two.ContractAddress {

					test[tc.Platform.Coin.Slug] = tc.ContractAddress

				}

				helo2 := Data2{
					Name:            two.Name,
					ID:              two.ID,
					Symbol:          two.Symbol,
					Slug:            two.Slug,
					ContractAddress: test,
				}

				helo = append(helo, helo2)

			}

		}

	}
	err = WriteFile(file2, helo)
	if err != nil {
		panic("Write in file")
	}

}

/*
   {
     "id": 1,
     "rank": 1,
     "name": "Bitcoin",
     "symbol": "BTC",
     "slug": "bitcoin",
     "is_active": 1,
     "status": 1,
     "first_historical_data": "2010-07-13T00:05:00Z",
     "last_historical_data": "2024-12-28T10:45:00Z",
     "platform": null,
     "cotracts":
     {
       "etherium":"0x21123123"
     }
*/
