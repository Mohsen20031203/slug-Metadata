package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"time"
)

type AutoGenerated struct {
	Status struct{} `json:"status"`
	Data   []struct {
		ID                  int         `json:"id"`
		Rank                int         `json:"rank"`
		Name                string      `json:"name"`
		Symbol              string      `json:"symbol"`
		Slug                string      `json:"slug"`
		IsActive            int         `json:"is_active"`
		Status              int         `json:"status"`
		FirstHistoricalData time.Time   `json:"first_historical_data"`
		LastHistoricalData  time.Time   `json:"last_historical_data"`
		Platform            interface{} `json:"platform"`
	} `json:"data"`
}

type AutoGenerated2 struct {
	Status interface{}     `json:"status"`
	Data   map[string]Data `json:"data"`
}

type Data struct {
	ID              int         `json:"id"`
	Name            string      `json:"name"`
	Symbol          string      `json:"symbol"`
	Category        string      `json:"category"`
	Description     string      `json:"description"`
	Slug            string      `json:"slug"`
	Logo            string      `json:"logo"`
	Subreddit       string      `json:"subreddit"`
	Notice          string      `json:"notice"`
	Tags            []string    `json:"tags"`
	TagNames        []string    `json:"tag-names"`
	TagGroups       []string    `json:"tag-groups"`
	Urls            interface{} `json:"urls"`
	Platform        interface{} `json:"platform"`
	DateAdded       time.Time   `json:"date_added"`
	TwitterUsername string      `json:"twitter_username"`
	IsHidden        int         `json:"is_hidden"`
	DateLaunched    time.Time   `json:"date_launched"`
	ContractAddress []struct {
		ContractAddress string `json:"contract_address"`
		Platform        struct {
			Name string `json:"name"`
			Coin struct {
				ID     int    `json:"id,string"`
				Name   string `json:"name"`
				Symbol string `json:"symbol"`
				Slug   string `json:"slug"`
			} `json:"coin"`
		} `json:"platform"`
	} `json:"contract_address"`
	SelfReportedCirculatingSupply interface{} `json:"self_reported_circulating_supply"`
	SelfReportedTags              interface{} `json:"self_reported_tags"`
	SelfReportedMarketCap         interface{} `json:"self_reported_market_cap"`
	InfiniteSupply                bool        `json:"infinite_supply"`
}

type Data2 struct {
	ID              int               `json:"id"`
	Name            string            `json:"name"`
	Symbol          string            `json:"symbol"`
	Slug            string            `json:"slug"`
	ContractAddress map[string]string `json:"contractAddress"`
}

func GetApi[T any](tokenData T, url string) (T, error) {
	resp, err := http.Get(url)
	if err != nil {
		return tokenData, err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return tokenData, err
	}

	if err := json.Unmarshal(body, &tokenData); err != nil {
		log.Print(body)
		return tokenData, err
	}
	return tokenData, nil
}

func WriteFile[T any](file *os.File, tokenData T) error {
	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	if err := encoder.Encode(tokenData); err != nil {
		return fmt.Errorf("Error encoding data:", err)
	}
	return nil
}

func ReadFile(file *os.File, tokenData *AutoGenerated) {
	decoder := json.NewDecoder(file)
	if err := decoder.Decode(&tokenData.Data); err != nil {
		fmt.Println(err)
	}
}

func getMapURL(baseURL, endpoint string, start int) string {
	if start == 0 {
		return baseURL + endpoint
	}
	return fmt.Sprintf("%s%s&start=%d", baseURL, endpoint, start)
}

func main() {

	const (
		baseURL      = "https://api.vultisig.com/cmc/v1/cryptocurrency"
		mapEndpoint  = "/map?sort=id&limit=5000"
		infoEndpoint = "/info?id="
	)

	var apiResponse AutoGenerated
	var err error
	var infoURL string
	var dataCollection []Data2

	file2, err := os.OpenFile("Result.json", os.O_APPEND|os.O_CREATE|os.O_RDWR, 0644)
	if err != nil {
		fmt.Println("Error opening/creating file:", err)
		return
	}
	defer file2.Close()

	for i := 0; ; i += 5000 {

		apiOneURL := getMapURL(baseURL, mapEndpoint, i)
		apiResponse, err = GetApi(apiResponse, apiOneURL)
		if err != nil {
			panic("error for api one")
		}

		if len(apiResponse.Data) == 0 {
			break
		}
		lastBatch := len(apiResponse.Data) < 5000

		var idCount int
		infoURL = "https://api.vultisig.com/cmc/v1/cryptocurrency/info?id="
		idBatch := make([]string, 0)

		for _, m := range apiResponse.Data {

			idBatch = append(idBatch, fmt.Sprintf("%d", m.ID))
			idCount++
			if idCount == 1000 || (lastBatch && len(apiResponse.Data) == idCount) {

				var ApiTwo AutoGenerated2
				idCount = 0
				infoURL = infoURL + strings.Join(idBatch, ",")

				ApiTwo, err = GetApi(ApiTwo, infoURL)
				if err != nil {
					panic("error for api one")
				}

				infoURL = "https://api.vultisig.com/cmc/v1/cryptocurrency/info?id="
				idBatch = nil

				for _, two := range ApiTwo.Data {

					test := make(map[string]string)
					for _, tc := range two.ContractAddress {
						test[tc.Platform.Coin.Slug] = tc.ContractAddress
					}

					helo2 := Data2{
						Name:            two.Name,
						ID:              two.ID,
						Symbol:          two.Symbol,
						Slug:            two.Slug,
						ContractAddress: test,
					}

					dataCollection = append(dataCollection, helo2)

				}

			}

		}
	}

	err = WriteFile(file2, dataCollection)
	if err != nil {
		panic("Write in file")
	}

}

/*
   {
     "id": 1,
     "rank": 1,
     "name": "Bitcoin",
     "symbol": "BTC",
     "slug": "bitcoin",
     "is_active": 1,
     "status": 1,
     "first_historical_data": "2010-07-13T00:05:00Z",
     "last_historical_data": "2024-12-28T10:45:00Z",
     "platform": null,
     "cotracts":
     {
       "etherium":"0x21123123"
     }
*/
